{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar _nodeHtmlParser = require(\"node-html-parser\");\nvar _constants = require(\"./constants\");\nvar MIDDLEWARE_TIME_BUDGET = 10;\nvar MAXIMUM_IMAGE_PRELOADS = 2;\nvar IMAGE_PRELOAD_SIZE_THRESHOLD = 2500;\nvar middlewareRegistry = [];\nfunction registerPostProcessor(name, middleware, condition) {\n  middlewareRegistry.push({\n    name: name,\n    middleware: middleware,\n    condition: condition || null\n  });\n}\nfunction processHTML(_x, _x2, _x3) {\n  return _processHTML.apply(this, arguments);\n}\nfunction _processHTML() {\n  _processHTML = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(html, data, options) {\n    var postProcessData, root, document, callMiddleWare, _callMiddleWare, i, middleware;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _callMiddleWare = function _callMiddleWare3() {\n              _callMiddleWare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(middleware, name) {\n                var timer, inspectTime;\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        timer = Date.now();\n                        middleware.inspect(root, postProcessData, data);\n                        inspectTime = Date.now() - timer;\n                        _context3.next = 5;\n                        return middleware.mutate(document, postProcessData, data);\n                      case 5:\n                        document = _context3.sent;\n                        timer = Date.now() - timer;\n                        if (timer > MIDDLEWARE_TIME_BUDGET) {\n                          console.warn(\"The postprocess middleware \\\"\".concat(name, \"\\\" took \").concat(timer, \"ms(\").concat(inspectTime, \", \").concat(timer - inspectTime, \") to complete. This is longer than the \").concat(MIDDLEWARE_TIME_BUDGET, \" limit.\"));\n                        }\n                        return _context3.abrupt(\"return\");\n                      case 9:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n              return _callMiddleWare.apply(this, arguments);\n            };\n            callMiddleWare = function _callMiddleWare2(_x9, _x10) {\n              return _callMiddleWare.apply(this, arguments);\n            };\n            if (middlewareRegistry[0]) {\n              _context4.next = 4;\n              break;\n            }\n            return _context4.abrupt(\"return\", html);\n          case 4:\n            postProcessData = {\n              preloads: {\n                images: []\n              }\n            };\n            root = (0, _nodeHtmlParser.parse)(html);\n            document = html; // Calls the middleware, with some instrumentation and logging\n            i = 0;\n          case 8:\n            if (!(i < middlewareRegistry.length)) {\n              _context4.next = 16;\n              break;\n            }\n            middleware = middlewareRegistry[i];\n            if (!(!middleware.condition || middleware.condition(options))) {\n              _context4.next = 13;\n              break;\n            }\n            _context4.next = 13;\n            return callMiddleWare(middlewareRegistry[i].middleware, middlewareRegistry[i].name);\n          case 13:\n            i++;\n            _context4.next = 8;\n            break;\n          case 16:\n            return _context4.abrupt(\"return\", document);\n          case 17:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _processHTML.apply(this, arguments);\n}\nvar FontOptimizerMiddleware = /*#__PURE__*/function () {\n  function FontOptimizerMiddleware() {\n    var _this = this;\n    _classCallCheck(this, FontOptimizerMiddleware);\n    this.fontDefinitions = [];\n    this.mutate = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(markup, _data, options) {\n        var result, key, url, fontContent;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                result = markup;\n                if (options.getFontDefinition) {\n                  _context.next = 3;\n                  break;\n                }\n                return _context.abrupt(\"return\", markup);\n              case 3:\n                _context.t0 = _regeneratorRuntime().keys(_this.fontDefinitions);\n              case 4:\n                if ((_context.t1 = _context.t0()).done) {\n                  _context.next = 13;\n                  break;\n                }\n                key = _context.t1.value;\n                url = _this.fontDefinitions[key];\n                if (!(result.indexOf(\"<style data-href=\\\"\".concat(url, \"\\\">\")) > -1)) {\n                  _context.next = 9;\n                  break;\n                }\n                return _context.abrupt(\"continue\", 4);\n              case 9:\n                fontContent = options.getFontDefinition(url);\n                result = result.replace('</head>', \"<style data-href=\\\"\".concat(url, \"\\\">\").concat(fontContent, \"</style></head>\"));\n                _context.next = 4;\n                break;\n              case 13:\n                return _context.abrupt(\"return\", result);\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x4, _x5, _x6) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n  _createClass(FontOptimizerMiddleware, [{\n    key: \"inspect\",\n    value: function inspect(originalDom, _data, options) {\n      var _this2 = this;\n      if (!options.getFontDefinition) {\n        return;\n      } // collecting all the requested font definitions\n      originalDom.querySelectorAll('link').filter(function (tag) {\n        return tag.getAttribute('rel') === 'stylesheet' && tag.hasAttribute('data-href') && _constants.OPTIMIZED_FONT_PROVIDERS.some(function (url) {\n          var dataHref = tag.getAttribute('data-href');\n          return dataHref ? dataHref.startsWith(url) : false;\n        });\n      }).forEach(function (element) {\n        var url = element.getAttribute('data-href');\n        if (url) {\n          _this2.fontDefinitions.push(url);\n        }\n      });\n    }\n  }]);\n  return FontOptimizerMiddleware;\n}();\nvar ImageOptimizerMiddleware = /*#__PURE__*/function () {\n  function ImageOptimizerMiddleware() {\n    _classCallCheck(this, ImageOptimizerMiddleware);\n    this.mutate = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(markup, _data) {\n        var result, imagePreloadTags;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                result = markup;\n                imagePreloadTags = _data.preloads.images.filter(function (imgHref) {\n                  return !preloadTagAlreadyExists(markup, imgHref);\n                }).reduce(function (acc, imgHref) {\n                  return acc + \"<link rel=\\\"preload\\\" href=\\\"\".concat(imgHref, \"\\\" as=\\\"image\\\"/>\");\n                }, '');\n                return _context2.abrupt(\"return\", result.replace(/<link rel=\"preload\"/, \"\".concat(imagePreloadTags, \"<link rel=\\\"preload\\\"\")));\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      return function (_x7, _x8) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n  }\n  _createClass(ImageOptimizerMiddleware, [{\n    key: \"inspect\",\n    value: function inspect(originalDom, _data) {\n      var imgElements = originalDom.querySelectorAll('img');\n      var eligibleImages = [];\n      for (var i = 0; i < imgElements.length; i++) {\n        if (isImgEligible(imgElements[i])) {\n          eligibleImages.push(imgElements[i]);\n        }\n        if (eligibleImages.length >= MAXIMUM_IMAGE_PRELOADS) {\n          break;\n        }\n      }\n      _data.preloads.images = [];\n      for (var _i = 0, _eligibleImages = eligibleImages; _i < _eligibleImages.length; _i++) {\n        var imgEl = _eligibleImages[_i];\n        var src = imgEl.getAttribute('src');\n        if (src) {\n          _data.preloads.images.push(src);\n        }\n      }\n    }\n  }]);\n  return ImageOptimizerMiddleware;\n}();\nfunction isImgEligible(imgElement) {\n  var imgSrc = imgElement.getAttribute('src');\n  return !!imgSrc && sourceIsSupportedType(imgSrc) && imageIsNotTooSmall(imgElement) && imageIsNotHidden(imgElement);\n}\nfunction preloadTagAlreadyExists(html, href) {\n  var regex = new RegExp(\"<link[^>]*href[^>]*\".concat(href));\n  return html.match(regex);\n}\nfunction imageIsNotTooSmall(imgElement) {\n  // Skip images without both height and width--we don't know enough to say if\n  // they are too small\n  if (!(imgElement.hasAttribute('height') && imgElement.hasAttribute('width'))) {\n    return true;\n  }\n  try {\n    var heightAttr = imgElement.getAttribute('height');\n    var widthAttr = imgElement.getAttribute('width');\n    if (!heightAttr || !widthAttr) {\n      return true;\n    }\n    if (parseInt(heightAttr) * parseInt(widthAttr) <= IMAGE_PRELOAD_SIZE_THRESHOLD) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n  return true;\n} // Traverse up the dom from each image to see if it or any of it's\n// ancestors have the hidden attribute.\nfunction imageIsNotHidden(imgElement) {\n  var activeElement = imgElement;\n  while (activeElement.parentNode) {\n    if (activeElement.hasAttribute('hidden')) {\n      return false;\n    }\n    activeElement = activeElement.parentNode;\n  }\n  return true;\n} // Currently only filters out svg images--could be made more specific in the future.\nfunction sourceIsSupportedType(imgSrc) {\n  return !imgSrc.includes('.svg');\n} // Initialization\nregisterPostProcessor('Inline-Fonts', new FontOptimizerMiddleware(),\n// Using process.env because passing Experimental flag through loader is not possible.\n// @ts-ignore\nfunction (options) {\n  return options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS;\n});\nregisterPostProcessor('Preload Images', new ImageOptimizerMiddleware(),\n// @ts-ignore\nfunction (options) {\n  return options.optimizeImages || process.env.__NEXT_OPTIMIZE_IMAGES;\n});\nvar _default = processHTML;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../../../next-server/lib/post-process.ts"],"names":["MIDDLEWARE_TIME_BUDGET","MAXIMUM_IMAGE_PRELOADS","IMAGE_PRELOAD_SIZE_THRESHOLD","middlewareRegistry","registerPostProcessor","name","middleware","condition","push","processHTML","html","data","options","postProcessData","preloads","images","root","document","callMiddleWare","timer","Date","now","inspect","inspectTime","mutate","console","warn","i","length","FontOptimizerMiddleware","fontDefinitions","originalDom","_data","getFontDefinition","querySelectorAll","filter","tag","getAttribute","hasAttribute","OPTIMIZED_FONT_PROVIDERS","some","url","dataHref","startsWith","forEach","element","markup","result","key","indexOf","fontContent","replace","ImageOptimizerMiddleware","imgElements","eligibleImages","isImgEligible","imgEl","src","imagePreloadTags","imgHref","preloadTagAlreadyExists","reduce","acc","imgElement","imgSrc","sourceIsSupportedType","imageIsNotTooSmall","imageIsNotHidden","href","regex","RegExp","match","heightAttr","widthAttr","parseInt","err","activeElement","parentNode","includes","optimizeFonts","process","env","__NEXT_OPTIMIZE_FONTS","optimizeImages","__NEXT_OPTIMIZE_IMAGES"],"mappings":"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","sourcesContent":["import { parse, HTMLElement } from 'node-html-parser'\nimport { OPTIMIZED_FONT_PROVIDERS } from './constants'\n\nconst MIDDLEWARE_TIME_BUDGET = 10\nconst MAXIMUM_IMAGE_PRELOADS = 2\nconst IMAGE_PRELOAD_SIZE_THRESHOLD = 2500\n\ntype postProcessOptions = {\n  optimizeFonts: boolean\n  optimizeImages: boolean\n}\n\ntype renderOptions = {\n  getFontDefinition?: (url: string) => string\n}\n\ntype postProcessData = {\n  preloads: {\n    images: Array<string>\n  }\n}\n\ninterface PostProcessMiddleware {\n  inspect: (\n    originalDom: HTMLElement,\n    data: postProcessData,\n    options: renderOptions\n  ) => void\n  mutate: (\n    markup: string,\n    data: postProcessData,\n    options: renderOptions\n  ) => Promise<string>\n}\n\ntype middlewareSignature = {\n  name: string\n  middleware: PostProcessMiddleware\n  condition: ((options: postProcessOptions) => boolean) | null\n}\n\nconst middlewareRegistry: Array<middlewareSignature> = []\n\nfunction registerPostProcessor(\n  name: string,\n  middleware: PostProcessMiddleware,\n  condition?: (options: postProcessOptions) => boolean\n) {\n  middlewareRegistry.push({ name, middleware, condition: condition || null })\n}\n\nasync function processHTML(\n  html: string,\n  data: renderOptions,\n  options: postProcessOptions\n): Promise<string> {\n  // Don't parse unless there's at least one processor middleware\n  if (!middlewareRegistry[0]) {\n    return html\n  }\n  const postProcessData: postProcessData = {\n    preloads: {\n      images: [],\n    },\n  }\n  const root: HTMLElement = parse(html)\n  let document = html\n  // Calls the middleware, with some instrumentation and logging\n  async function callMiddleWare(\n    middleware: PostProcessMiddleware,\n    name: string\n  ) {\n    let timer = Date.now()\n    middleware.inspect(root, postProcessData, data)\n    const inspectTime = Date.now() - timer\n    document = await middleware.mutate(document, postProcessData, data)\n    timer = Date.now() - timer\n    if (timer > MIDDLEWARE_TIME_BUDGET) {\n      console.warn(\n        `The postprocess middleware \"${name}\" took ${timer}ms(${inspectTime}, ${\n          timer - inspectTime\n        }) to complete. This is longer than the ${MIDDLEWARE_TIME_BUDGET} limit.`\n      )\n    }\n    return\n  }\n\n  for (let i = 0; i < middlewareRegistry.length; i++) {\n    let middleware = middlewareRegistry[i]\n    if (!middleware.condition || middleware.condition(options)) {\n      await callMiddleWare(\n        middlewareRegistry[i].middleware,\n        middlewareRegistry[i].name\n      )\n    }\n  }\n\n  return document\n}\n\nclass FontOptimizerMiddleware implements PostProcessMiddleware {\n  fontDefinitions: Array<string> = []\n  inspect(\n    originalDom: HTMLElement,\n    _data: postProcessData,\n    options: renderOptions\n  ) {\n    if (!options.getFontDefinition) {\n      return\n    }\n    // collecting all the requested font definitions\n    originalDom\n      .querySelectorAll('link')\n      .filter(\n        (tag: HTMLElement) =>\n          tag.getAttribute('rel') === 'stylesheet' &&\n          tag.hasAttribute('data-href') &&\n          OPTIMIZED_FONT_PROVIDERS.some((url) => {\n            const dataHref = tag.getAttribute('data-href')\n            return dataHref ? dataHref.startsWith(url) : false\n          })\n      )\n      .forEach((element: HTMLElement) => {\n        const url = element.getAttribute('data-href')\n        if (url) {\n          this.fontDefinitions.push(url)\n        }\n      })\n  }\n  mutate = async (\n    markup: string,\n    _data: postProcessData,\n    options: renderOptions\n  ) => {\n    let result = markup\n    if (!options.getFontDefinition) {\n      return markup\n    }\n    for (const key in this.fontDefinitions) {\n      const url = this.fontDefinitions[key]\n      if (result.indexOf(`<style data-href=\"${url}\">`) > -1) {\n        // The font is already optimized and probably the response is cached\n        continue\n      }\n      const fontContent = options.getFontDefinition(url)\n      result = result.replace(\n        '</head>',\n        `<style data-href=\"${url}\">${fontContent}</style></head>`\n      )\n    }\n    return result\n  }\n}\n\nclass ImageOptimizerMiddleware implements PostProcessMiddleware {\n  inspect(originalDom: HTMLElement, _data: postProcessData) {\n    const imgElements = originalDom.querySelectorAll('img')\n    let eligibleImages: Array<HTMLElement> = []\n    for (let i = 0; i < imgElements.length; i++) {\n      if (isImgEligible(imgElements[i])) {\n        eligibleImages.push(imgElements[i])\n      }\n      if (eligibleImages.length >= MAXIMUM_IMAGE_PRELOADS) {\n        break\n      }\n    }\n\n    _data.preloads.images = []\n\n    for (const imgEl of eligibleImages) {\n      const src = imgEl.getAttribute('src')\n      if (src) {\n        _data.preloads.images.push(src)\n      }\n    }\n  }\n  mutate = async (markup: string, _data: postProcessData) => {\n    let result = markup\n    let imagePreloadTags = _data.preloads.images\n      .filter((imgHref) => !preloadTagAlreadyExists(markup, imgHref))\n      .reduce(\n        (acc, imgHref) =>\n          acc + `<link rel=\"preload\" href=\"${imgHref}\" as=\"image\"/>`,\n        ''\n      )\n    return result.replace(\n      /<link rel=\"preload\"/,\n      `${imagePreloadTags}<link rel=\"preload\"`\n    )\n  }\n}\n\nfunction isImgEligible(imgElement: HTMLElement): boolean {\n  let imgSrc = imgElement.getAttribute('src')\n  return (\n    !!imgSrc &&\n    sourceIsSupportedType(imgSrc) &&\n    imageIsNotTooSmall(imgElement) &&\n    imageIsNotHidden(imgElement)\n  )\n}\n\nfunction preloadTagAlreadyExists(html: string, href: string) {\n  const regex = new RegExp(`<link[^>]*href[^>]*${href}`)\n  return html.match(regex)\n}\n\nfunction imageIsNotTooSmall(imgElement: HTMLElement): boolean {\n  // Skip images without both height and width--we don't know enough to say if\n  // they are too small\n  if (\n    !(imgElement.hasAttribute('height') && imgElement.hasAttribute('width'))\n  ) {\n    return true\n  }\n  try {\n    const heightAttr = imgElement.getAttribute('height')\n    const widthAttr = imgElement.getAttribute('width')\n    if (!heightAttr || !widthAttr) {\n      return true\n    }\n\n    if (\n      parseInt(heightAttr) * parseInt(widthAttr) <=\n      IMAGE_PRELOAD_SIZE_THRESHOLD\n    ) {\n      return false\n    }\n  } catch (err) {\n    return true\n  }\n  return true\n}\n\n// Traverse up the dom from each image to see if it or any of it's\n// ancestors have the hidden attribute.\nfunction imageIsNotHidden(imgElement: HTMLElement): boolean {\n  let activeElement = imgElement\n  while (activeElement.parentNode) {\n    if (activeElement.hasAttribute('hidden')) {\n      return false\n    }\n    activeElement = activeElement.parentNode as HTMLElement\n  }\n  return true\n}\n\n// Currently only filters out svg images--could be made more specific in the future.\nfunction sourceIsSupportedType(imgSrc: string): boolean {\n  return !imgSrc.includes('.svg')\n}\n\n// Initialization\nregisterPostProcessor(\n  'Inline-Fonts',\n  new FontOptimizerMiddleware(),\n  // Using process.env because passing Experimental flag through loader is not possible.\n  // @ts-ignore\n  (options) => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS\n)\n\nregisterPostProcessor(\n  'Preload Images',\n  new ImageOptimizerMiddleware(),\n  // @ts-ignore\n  (options) => options.optimizeImages || process.env.__NEXT_OPTIMIZE_IMAGES\n)\n\nexport default processHTML\n"]},"metadata":{},"sourceType":"script"}